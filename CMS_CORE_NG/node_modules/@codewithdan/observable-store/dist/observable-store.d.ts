import { Observable } from 'rxjs';
import { ObservableStoreSettings, StateHistory, ObservableStoreGlobalSettings, StateWithPropertyChanges, ObservableStoreExtension } from './interfaces';
/**
 * Executes a function on `state` and returns a version of T
 * @param state - the original state model
 */
export declare type stateFunc<T> = (state: T) => Partial<T>;
/**
 * Core functionality for ObservableStore
 * providing getState(), setState() and additional functionality
 */
export declare class ObservableStore<T> {
    private _settings;
    private _stateDispatcher$;
    private _stateWithChangesDispatcher$;
    /**
     * Subscribe to store changes in the particlar slice of state updated by a Service.
     * If the store contains 'n' slices of state each being managed by one of 'n' services, then changes in any
     * of the other slices of state will not generate values in the `stateChanged` stream.
     * Returns an RxJS Observable containing the current store state (or a specific slice of state if a `stateSliceSelector` has been specified).
     */
    stateChanged: Observable<T>;
    /**
     * Subscribe to store changes in the particlar slice of state updated by a Service and also include the properties that changed as well.
     * Upon subscribing to `stateWithPropertyChanges` you will get back an object containing state (which has the current slice of store state)
     * and `stateChanges` (which has the individual properties/data that were changed in the store).
     */
    stateWithPropertyChanges: Observable<StateWithPropertyChanges<T>>;
    /**
     * Subscribe to global store changes i.e. changes in any slice of state of the store. The global store may consist of 'n'
     * slices of state each managed by a particular service. This property notifies of a change in any of the 'n' slices of state.
     * Returns an RxJS Observable containing the current store state.
     */
    globalStateChanged: Observable<T>;
    /**
     * Subscribe to global store changes i.e. changes in any slice of state of the store and also include the properties that changed as well.
     * The global store may consist of 'n' slices of state each managed by a particular service.
     * This property notifies of a change in any of the 'n' slices of state. Upon subscribing to `globalStateWithPropertyChanges` you will get
     * back an object containing state (which has the current store state) and `stateChanges`
     * (which has the individual properties/data that were changed in the store).
     */
    globalStateWithPropertyChanges: Observable<StateWithPropertyChanges<T>>;
    /**
     * Retrieve state history. Assumes trackStateHistory setting was set on the store.
     */
    readonly stateHistory: StateHistory<T>[];
    constructor(settings: ObservableStoreSettings);
    /**
     * get/set global settings throughout the application for ObservableStore.
     * See the [Observable Store Settings](https://github.com/danwahlin/observable-store#store-settings-per-service) documentation
     * for additional information. Note that global settings can only be set once as the application first loads.
     */
    static globalSettings: ObservableStoreGlobalSettings;
    /**
     * Provides access to all services that interact with ObservableStore. Useful for extensions
     * that need to be able to access a specific service.
     */
    static readonly allStoreServices: any[];
    /**
     * Used to add an extension into ObservableStore. The extension must implement the
     * `ObservableStoreExtension` interface.
     */
    static addExtension(extension: ObservableStoreExtension): void;
    /**
     * Used to initialize the store's starting state. An error will be thrown if this is called and store state already exists.
     * No notifications are sent out when the store state is initialized by calling initializeStoreState().
     */
    static initializeState(state: any): void;
    /**
     * Used to reset the state of the store to a desired value for all services that derive
     * from ObservableStore<T> to a desired value.
     * A state change notification and global state change notification is sent out to subscribers if the dispatchState parameter is true (the default value).
     */
    static resetState(state: any, dispatchState?: boolean): void;
    /**
     * Clear/null the store state for all services that use it.
     */
    static clearState(dispatchState?: boolean): void;
    private static dispatchToAllServices;
    /**
     * Retrieve store's state. If using TypeScript (optional) then the state type defined when the store
     * was created will be returned rather than `any`. The deepCloneReturnedState boolean parameter (default is true) can be used
     * to determine if the returned state will be deep cloned or not. If set to false, a reference to the store state will
     * be returned and it's up to the user to ensure the state isn't change from outside the store. Setting it to false can be
     * useful in cases where read-only cached data is stored and must be retrieved as quickly as possible without any cloning.
     */
    protected getState(deepCloneReturnedState?: boolean): T;
    /**
     * Retrieve a specific property from the store's state which can be more efficient than getState()
     * since only the defined property value will be returned (and cloned) rather than the entire
     * store value. If using TypeScript (optional) then the generic property type used with the
     * function call will be the return type.
     */
    protected getStateProperty<TProp>(propertyName: string, deepCloneReturnedState?: boolean): TProp;
    /**
     * Set store state. Pass the state to be updated as well as the action that is occuring.
     * The state value can be a function [(see example)](https://github.com/danwahlin/observable-store#store-api).
     * The latest store state is returned.
     * The dispatchState parameter can be set to false if you do not want to send state change notifications to subscribers.
     * The deepCloneReturnedState boolean parameter (default is true) can be used
     * to determine if the state will be deep cloned before it is added to the store. Setting it to false can be
     * useful in cases where read-only cached data is stored and must added to the store as quickly as possible without any cloning.
     */
    protected setState(state: Partial<T> | stateFunc<T>, action?: string, dispatchState?: boolean, deepCloneState?: boolean): T;
    /**
     * Add a custom state value and action into the state history. Assumes `trackStateHistory` setting was set
     * on store or using the global settings.
     */
    protected logStateAction(state: any, action: string): void;
    /**
     * 	Reset the store's state history to an empty array.
     */
    protected resetStateHistory(): void;
    private _updateState;
    private _getStateOrSlice;
    /**
     * Dispatch the store's state without modifying the store state. Service state can be dispatched as well as the global store state.
     * If `dispatchGlobalState` is false then global state will not be dispatched to subscribers (defaults to `true`).
     */
    protected dispatchState(stateChanges: Partial<T>, dispatchGlobalState?: boolean): void;
}
